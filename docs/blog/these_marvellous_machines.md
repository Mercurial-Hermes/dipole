# These Marvellous Machines

# Hamish MacDonald
*December 2025*

I don’t remember exactly when my fascination with computers turned into a deeper curiosity about how they actually work. It wasn’t always there.

My professional background is in quantitative analytics, in the financial world. Like many people, I came to computing through tools that promised leverage: spreadsheets, databases, scripts that moved data from one place to another. When I first encountered Python, it felt like a revelation. Ideas that had been awkward or fragile suddenly became expressible. Things worked. Data flowed. I could hold the whole program in my head.

At the time, that was enough. Deadlines have a way of narrowing curiosity. When something works, you move on.

And yet, even then, there was a persistent feeling that something important was happening just out of view. Python felt too capable, too accommodating, to be simple. It was friendly—but it was clearly standing on something solid.

That sense lingered for years.

Eventually, I stumbled across a series of talks that explored the internals of Python itself. For the first time, I saw the interpreter not as a magical environment, but as a concrete program. A C program. A machine built from decisions, loops, and data structures. I learned how to browse the source code, how the read–eval–print loop worked, how the illusion of effortlessness was sustained.

What struck me wasn’t the complexity—though there was plenty of it—but the fact that it held together. Somehow, layers of machinery had been assembled in such a way that they felt simple at the surface. That realization changed how I thought about software. If something as approachable as Python rested on such foundations, what else was hiding underneath the tools I used every day?

That question pulled me further down.

I began reading about the early days of operating systems, about projects that failed and the ideas that survived them. I learned about Ken Thompson working with limited hardware, exploring what was possible when you understood the machine well enough to bend it to your will. I learned how early versions of Unix were written directly in assembly, and what that implied: an intimate, physical relationship with the processor itself.

Then I read about Dennis Ritchie, and the decision to build a system using a language designed for the task. Not to abstract the machine away, but to meet it halfway. To create a tool that was expressive without being disconnected from reality.

What fascinated me wasn’t just what they built, but how they thought. These weren’t magicians. They were people who had learned to align their thinking with the structure of the machine—people who chose simplicity not because it was easy, but because they understood complexity deeply enough to avoid it.

This idea of layers — simple operations supporting richer structures, each one carefully constrained—became a recurring theme. At the bottom, processors perform unimaginably fast but fundamentally simple actions. On top of that, we build representations, conventions, languages, systems. Somehow, meaning emerges.

I wanted to understand that process, not as folklore, but as something tangible.

So I learned C. I worked through the examples in K&R. I struggled. Memory management was unforgiving. Mistakes were quiet until they were not. Progress was slower, but it felt different. More grounded.

It was during this period that I began using debuggers in earnest. At first, they were practical tools—ways to fix problems. But over time, they became something else entirely.

A debugger lets you stop time.

You can pause the flow of execution, look at the state of the machine, and ask: what is happening right now? Not what you intended. Not what the code suggests. What is actually occurring.

That ability—to freeze a running program and inspect it as a living system—felt extraordinary. Registers, memory, control flow: all of it visible, connected directly to a real binary. No diagrams. No metaphors. Just the machine, waiting.

What surprised me was how little this perspective appeared in educational material. Debuggers were treated as emergency tools, or as productivity aids for experts. Rarely as instruments for learning—ways to see how abstraction meets reality.

And yet, for me, they were the clearest window I had found into how computers truly work.

Over time, I became less interested in using machines efficiently, and more interested in understanding how thinking and machinery align at all. How simple operations give rise to complex behavior. How careful design can make power feel effortless. How layers can both reveal and conceal.

That fascination hasn’t faded. If anything, it has deepened.

These machines we work with every day are marvellous—not because they are mysterious, but because they are comprehensible, if we choose to look closely enough.
