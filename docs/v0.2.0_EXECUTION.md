## ‚úÖ Dipole v0.2.0 ‚Äî Execution Checklist (Living Document)
__Purpose:__
This document tracks the concrete technical work required to deliver Dipole v0.2.0.
It is a **granular checklist**, not a roadmap or design doc.

Status markers:
- ‚úÖ Done
- üü° In progress
- ‚è≥ Planned / To do
= ‚ùå Deferred (explicitly out of v0.2 scope)

---

## 0. Baseline (v0.1.0 confirmation)
These items establish the starting point and should not regress.
- ‚úÖ PTY-backed LLDB spawning and IO
- ‚úÖ Reliable LLDB prompt detection
- ‚úÖ LLDBDriver test suite passing
- ‚úÖ Basic REPL (step, next, continue, bt, reg read)
- ‚úÖ Raw LLDB passthrough escape hatch
- ‚úÖ tmux bootstrap with register snapshot pane
- ‚úÖ v0.1.0 tagged and documented

---

## 1. Architectural Groundwork (v0.2 spine)
These are **enabling changes**. Nothing else in v0.2 is stable without them.

### 1.1 Controller / Broker
- ‚è≥ Define Dipole Controller role explicitly
- ‚è≥ Single process owns:
  - LLDB PTY
  - session lifecycle
  - authoritative debugger state
- ‚è≥ Serialized command execution queue
- ‚è≥ Explicit session states:
  - `Stopped`
  - `Running`
  - `Exited`
  
### 1.2 IPC Layer (minimal, v0.2)
- ‚è≥ Choose IPC mechanism (Unix domain socket recommended)
- ‚è≥ Define socket path convention (`/tmp/dipole/<session>/ctl.sock`)
- ‚è≥ Define minimal request/response protocol:
  - `ExecRaw`
  - `Continue / Step / Next / Finish`
  - `RefreshRegs / RefreshDisasm / RefreshWhere`
  - `GetState`
- ‚è≥ Graceful handling of client disconnects

### 1.3 Stop Event Pipeline
- ‚è≥ Detect stop events robustly
- ‚è≥ Capture stop reason (breakpoint, step, signal, exit)
- ‚è≥ On stop:
  - refresh registers
  - refresh PC context (‚Äúwhere am I‚Äù)
  - refresh disassembly around PC
- ‚è≥ Cache last-stop derived state

---

## 2. tmux as First-Class UI Surface

### 2.1 Layouts
- ‚è≥ Define canonical tmux layouts:
  - `teach` (REPL | regs | where | disasm)
  - `minimal` (REPL | regs)
- ‚è≥ Implement `dipole tmux layout <name>`
- ‚è≥ Ensure layouts are idempotent and restart-safe

### 2.2 Pane Roles
- ‚è≥ REPL pane (interactive client)
- ‚è≥ Register pane (viewer-only)
- ‚è≥ ‚ÄúWhere am I‚Äù pane (PC, symbol, source)
- ‚è≥ Disassembly pane (PC-centric)
- ‚è≥ Optional memory pane (read-only)

### 2.3 Pane Refresh Model
- ‚è≥ Stop-driven automatic refresh
- ‚è≥ Manual refresh trigger from any pane
- ‚è≥ Atomic snapshot updates (no partial writes)
- ‚è≥ Clear ‚Äútarget running‚Äù feedback when refresh is not possible

---

## 3. Debugger Capability Expansion (LLDB-facing)

### 3.1 Target Lifecycle
- ‚è≥ `run [args...]`
- ‚è≥ `attach <pid>`
- ‚è≥ `detach`
- ‚è≥ `restart`
- ‚è≥ `kill`
- ‚è≥ Display current PID / TID in status context

### 3.2 Breakpoints
- ‚è≥ `b <file:line | symbol>`
- ‚è≥ `bl (list)`
- ‚è≥ `bd / be` (disable / enable)
- ‚è≥ `bc` (clear)
- ‚è≥ Surface stop reason on hit

### 3.3 Stepping Depth
- ‚è≥ `finish` (step out)
- ‚è≥ `si / ni` (instruction stepping)
- ‚è≥ Clear distinction between source-step and instruction-step

### 3.4 Thread / Frame Navigation
- ‚è≥ `thread list`
- ‚è≥ `thread select`
- ‚è≥ `frame info`
- ‚è≥ `up / down`
- ‚è≥ `frame variable`

---

## 4. Pedagogical ‚ÄúGold‚Äù Views
These are the **value-add of v0.2**.

### 4.1 Registers
- ‚è≥ Structured register parsing (best-effort)
- ‚è≥ Stable register ordering
- ‚è≥ Register diff since last stop
- ‚è≥ Highlight changed registers in pane

### 4.2 PC Context (‚ÄúWhere am I‚Äù)
- ‚è≥ PC value
- ‚è≥ Symbol lookup
- ‚è≥ Source file + line (when available)
- ‚è≥ Fallback when debug info missing

### 4.3 Disassembly
- ‚è≥ Disassembly centered on PC
- ‚è≥ Configurable instruction window
- ‚è≥ Clear marking of current PC
- ‚è≥ Instruction stepping coherence

### 4.4 Memory (Read-only)
- ‚è≥ `memory read` wrapper
- ‚è≥ Hex + ASCII view
- ‚è≥ Safe defaults (small ranges)
- ‚ùå Memory write (explicitly deferred)

---

## 5. Robustness & Failure Handling

- ‚è≥ Detect LLDB exit reliably
- ‚è≥ Transition session to `Exited`
- ‚è≥ Prevent stale pane updates
- ‚è≥ Clear messaging when session is dead
- ‚è≥ Safe shutdown of controller and clients
- ‚è≥ Ctrl-C / interrupt handling during long runs

---

## 6. UX & Quality-of-Life

- ‚è≥ Command aliases aligned with LLDB muscle memory
- ‚è≥ `help` command describing Dipole subset
- ‚è≥ Command history
- ‚è≥ Clear error messages (no silent failure)
- ‚è≥ Preserve raw LLDB passthrough

---

## 7. Documentation & Release Hygiene

- ‚è≥ Update `ARCHITECTURE.md` with v0.2 runtime topology
- ‚è≥ Update `ROADMAP.md` (done)
- ‚è≥ Add `V0_2_CHECKLIST.md` (this file)
- ‚è≥ Dev-log entries for major milestones
- ‚è≥ Define **v0.2.0 Definition of Done**
- ‚è≥ Tag `v0.2.0-alpha`
- ‚è≥ Tag `v0.2.0-beta`
- ‚è≥ Tag `v0.2.0`

---

8. Explicit Non-Goals for v0.2 (Guard Rails)
- ‚ùå Replacing LLDB backend
- ‚ùå liblldb / SB API integration
- ‚ùå Remote debugging
- ‚ùå Kernel debugging
- ‚ùå Full graphical UI
- ‚ùå Performance profiling

9. Definition of Done (v0.2.0)

v0.2.0 is complete when:
- A learner can run Dipole entirely from tmux
- Multiple panes show consistent, stop-driven state
- Core debugging workflows no longer require raw LLDB
- Dipole never lies about process state
- The architecture is understandable by reading the code

## Usage Notes

This document is **expected to change**
Items may move between sections
Deferring something explicitly is success, not failure
