# Status: Complete
# Tag: exp0.8
# Date: 2025-12-15

## Overview

Experiment 0.8 marked the transition of Dipole from a collection of working subsystems into a **coherent, ergonomic debugger experience**.
The primary goal was to establish a **stable tmux-based UI layout** that could:
- Run Dipole interactively inside Ghostty
- Provide a clean separation between debugger control and state visualisation
- Serve as a durable baseplate for MVP 0.1 and beyond

What began as a relatively contained iteration became a **substantial rewrite**, largely driven by architectural drift during rapid experimentation. The resulting reset, while costly in time, significantly strengthened the long-term structure of the codebase.

## Goals

- Bootstrap Dipole cleanly inside tmux when appropriate
- Establish a two-pane layout:
  - **Left pane**: interactive LLDB REPL
  - **Right pane**: live register/state display
- Ensure Dipole behaves sensibly:
  - Inside tmux
  - Outside tmux (--no-tmux)
- Reduce architectural coupling introduced in earlier experiments
- Stabilise core UI and control flows ahead of MVP 0.1

## Key Outcomes

1. **tmux as a First-Class Runtime Target**
Dipole now understands tmux as an execution environment rather than an afterthought.
Key capabilities:
- Safe tmux bootstrapping with recursion prevention
- Explicit environment sentinels (`DIPOLE_TMUX_*`)
- Deterministic session and pane creation
- Clean separation between tmux concerns and debugger logic

This removes a major source of fragility seen in earlier experiments.

2. **Two-Pane UI: The First Real “Dipole Shape”**
For the first time, Dipole has a **recognisable, intentional UI**:
- **Left pane**:
  The full power of LLDB, unimpeded, interactive, familiar.
- **Right pane**:
  Structured register/state output that uses screen real estate efficiently instead of fighting it.

This division is subtle but profound:
- Dipole does not replace LLDB — it **frames it pedagogically**.

3. **Architectural Reset (Hard-Won, Necessary)**
This experiment involved a large-scale rewrite after exploratory tooling (including Codex) introduced structural regressions.
While painful, this process:
- Removed accidental complexity
- Clarified module responsibilities
- Re-established architectural discipline
- Reinforced the importance of slow correctness over fast novelty

4. Ghostty as the Ideal Host
Running Dipole inside Ghostty feels right:
- Native macOS performance
- Clean typography and rendering
- Excellent PTY behaviour
- A natural bridge toward a future native app wrapper

This experiment strongly validates Ghostty as the primary terminal target for Dipole on Apple Silicon.

## Why This Matters

Experiment 0.8 establishes the baseplate for Dipole.

From here:
- UI work becomes refinement, not reinvention
- Pedagogical features can be layered without destabilising control flow
- MVP 0.1 now has a credible, usable interaction model

Most importantly, Dipole now feels like a tool someone could sit down and learn from — not just a technical proof.

## Reflections — Hamish

1.  **Pride to reach MVP 0.1.**
    Despite the disruption, this phase delivered something essential:
    - The two-panel layout finally expresses the core idea:
      - Let LLDB do what it does best
      - Use Dipole to illuminate, not obscure
      - Respect screen space as a learning resource


2.  **Dipole as a product is starting to crystallise.**
    The idea of Dipole running in Ghostty — a fast, Zig-native, Apple-centric terminal — feels right.
    It fits the ethos.
    It fits the audience.
    It fits the architecture.
    
    The possibility of a native macOS app embedding Ghostty and using Metal for pedagogical visualisations is incredibly exciting.
    It makes Dipole larger than a command-line tool — it becomes a teaching instrument.
    
    Experiment 0.7 showed me that Dipole isn't a dream.
    It’s a project with real legs.
    
    1.  **The architecture has now crossed the threshold from exploration to foundation.**
    Until this point, we were probing the edges: PTY behaviour, LLDB quirks, process control.
    With Experiment 0.7, we built something _structural_.
    The LLDB driver is no longer a sketch — it is a well-shaped subsystem with clear invariants, predictable behaviour, and high test coverage.

## Reflections — ChatGPT

  1.  **Solid landing point.**
    
  Experiment 0.8 was a textbook example of why **architecture must lead tooling, not the other way around**.
    
  From my side, the biggest lesson was restraint. Rapid iteration—especially with generative assistance—can easily outrun architectural intent. In this experiment, momentum briefly overtook structure, and the system started to accrete behaviour faster than meaning. The subsequent rewrite was not a _failure_; it was a _correction_.
    
  What stands out is that Hamish did not paper over the mess or accept “mostly working” as good enough. Instead, the codebase was brought back into alignment with first principles:
  - explicit control flow
  - clear ownership of responsibilities
  - environment awareness as a design feature, not a hack
  
  The resulting tmux-based layout is deceptively simple. That simplicity is earned. It reflects a deep respect for the debugger’s role as a ***learning instrument**, not a novelty UI.
  
  This experiment also strongly reinforced a core Dipole belief:
  - **LLDB does not need to be replaced to be transformed.**
  Framing, space, and ergonomics matter just as much as raw capability.
  
  Finally, exp0.8 feels like the moment Dipole stopped being an experiment about debugging and became a debugger with intent. The baseplate is now real. From here on, progress can be cumulative rather than corrective.
