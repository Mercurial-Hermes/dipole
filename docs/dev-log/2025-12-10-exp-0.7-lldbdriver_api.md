# Status: Complete
# Tag: exp0.7
# Date: 2025-12-10

## Overview

Experiment 0.7 revisited and completed the implementation of the first proper `LLDBDriver.zig` module — the foundation of Dipole’s interactive debugging capability. This experiment delivered a **fully test-driven LLDB driver**, a **clean PTY abstraction**, and culminated in a **working Dipole REPL** capable of attaching to and stepping real processes.

Everything built here is the engine that the Dipole debugger will rely on for all future MVP and pedagogical features.

The experiment proceeded smoothly, largely due to the foundations laid in Exp0.6 (PTY correctness) and earlier experiments (trace model, LLDB exploration, etc.)

## Goals

- Implement a clean, testable, and robust `LLDBDriver.zig` module.
- Drive development using a TDD approach to ensure reliability and protect against API breakage.
- Conclude with a functional Dipole REPL that can:
- launch LLDB
- attach to a process
- send commands
- read output
- step the target
- shut down LLDB cleanly

This forms the minimal skeleton of a debugger.

## Why This Matters

1.  **It is the beating heart of MVP 0.1**
Dipole’s early value proposition is simple:
  _Expose LLDB’s power in a more ergonomic, more insightful, and more pedagogically rich interface._

To do that, Dipole needs a rock-solid, predictable core LLDB driver.

2.  **Reliability enables creativity**
Once the driver works flawlessly:
  - the REPL can evolve
  - richer TUI layers can be built
  - visualisations can be layered on top
  - Ghostty-integrated UX becomes possible
  - pedagogical insights can be generated

A debugger cannot be inspiring if it is unreliable.
This experiment laid the foundation for the inspiring part.

## Implementation Notes

### Conceptual Model — The LLDBDriver Architecture

`LLDBDriver` orchestrates four responsibilities:

1. **LLDB Process Lifecycle**

- Spawn LLDB via `posix_spawn`
- Attach to a target PID or launch a binary
- Shut LLDB down cleanly
- Track LLDB's PID for health checks (`isAlive()`)

2. **IO Through a PTY**

LLDB behaves correctly only when connected to a real terminal.

The driver uses:
- a PTY master → read LLDB output
- a PTY slave → bind LLDB stdin/stdout/stderr

This guarantees:
- interactive mode works
- prompts appear
- stepping behaves normally
- formatting is consistent

3. **Command Transmission**

- `sendLine("continue")`
- `sendLine("register read")`
- etc.

4. **Prompt Detection + Output Capture**
The driver must know when to stop reading LLDB output.
`waitForPrompt()` implements:
  - non-blocking reads
  - timeout handling
  - accumulation of output into a buffer
  - prompt detection (`" (lldb) "`)

This is the hardest part of building an interactive debugger.
Our implementation is clean, deterministic, and fully tested.

### Key Technical Achievements

1. **A fully test-driven LLDB driver**

We built 11 tests covering:
- PTY creation
- LLDB spawn
- attach
- launch
- command send
- prompt detection
- shutdown
- deinit
- process liveness

This is extremely important for long-term maintainability.

2. **A clean PTY abstraction**

A reusable `PtyPair` struct with:
- `.master_fd`
- `.slave_fd`
- `.close()` helper
- correct error handling
- macOS-specific behaviour accounted for

3. **Process lifecycle correctness**
LLDB now:
  - spawns correctly
  - returns valid prompt state
  - is detected when alive/not alive
  - terminates when requested
  - closes all FDs in deinit

This prevents zombie processes and FD leaks.

4. **A functional Dipole REPL**

For the first time, Dipole can be used:

```zig
dipole> attach 33029
dipole> register read
dipole> step
dipole> quit
```
This is a debugger.
A simple debugger — but a debugger nonetheless.

5. **Robust prompt-state handling**

Critical for driving LLDB safely.
The first version detects `(lldb)` and handles timeouts gracefully.

6. **Working integration with real processes**

We successfully attached to an infinite-looping C program and stepped through it.

This confirms that:
  - Apple Silicon architecture detection
  - register reading
  - code stepping
  - work in real-world conditions.

## Reflections — Hamish

1.  **Exp0.7 was simply a joy.**
    After the intense foundational work of previous days, this was a smooth and incredibly rewarding sprint.
    The TDD approach created clarity and confidence — the system feels stable, mechanical, and predictable.
    This is exactly what a debugger core must be.

2.  **Dipole as a product is starting to crystallise.**
    The idea of Dipole running in Ghostty — a fast, Zig-native, Apple-centric terminal — feels right.
    It fits the ethos.
    It fits the audience.
    It fits the architecture.
    
    The possibility of a native macOS app embedding Ghostty and using Metal for pedagogical visualisations is incredibly exciting.
    It makes Dipole larger than a command-line tool — it becomes a teaching instrument.
    
    Experiment 0.7 showed me that Dipole isn't a dream.
    It’s a project with real legs.

## Reflections — ChatGPT

1.  **The architecture has now crossed the threshold from exploration to foundation.**
    Until this point, we were probing the edges: PTY behaviour, LLDB quirks, process control.
    With Experiment 0.7, we built something _structural_.
    The LLDB driver is no longer a sketch — it is a well-shaped subsystem with clear invariants, predictable behaviour, and high test coverage.
    
    This is the turning point where a debugger becomes _buildable_.
    
2.  **Your instincts about pedagogy and system programming are completely aligned.**
    A debugger is a rare kind of tool:
      - it is both _instrument_ and _teacher_.
    Dipole has the potential to occupy that space uniquely — particularly on Apple Silicon, which remains underserved by modern pedagogical tooling.

    With a clean LLDB driver, future Dipole layers can focus on:
      - presenting registers meaningfully
      - visualising stack frames
      - showing memory changes step-by-step
      - rendering execution traces
      - turning low-level mechanics into learning moments
      
3.  **Ghostty as the long-term UI substrate is a powerful idea.**
    Not for MVP 0.1 — but as the long arc of the project.
    It lets Dipole:
      - remain terminal-native
      - remain Zig-native
      - gain graphical expressiveness
      - use GPU-backed rendering
      - bridge TUI and GUI worlds

    Dipole has the potential to be the Apple Silicon systems programming debugger — and also a beautiful teaching tool.
    
Experiment 0.7 was not just a milestone.
It was the emergence of Dipole’s core identity.
