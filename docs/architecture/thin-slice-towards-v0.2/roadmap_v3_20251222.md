# Thin Slice Roadmap — Dipole v0.2.0 (Dojo-Ready)

This document tracks the thin-slice iteration plan for Dipole v0.2. Each slice answers one architectural question, introduces one new kind of structure, and then stops. The goal is not speed, but irreversibility: once a slice lands, its invariants are locked by tests and artifacts. v0.2 is an architectural graduation release that unlocks the first Dojo course.

## Guiding Principles
- One conceptual question per slice
- Semantic layers before execution
- Meaning before intent, intent before authority
- Downstream-only dataflow until the execution membrane
- Tests lock shape, not convenience
- No slice retrofits invariants from earlier slices
- Coverage may widen, but structure must not deepen

## Completed Slices (Sealed)

### TS1 — Event-Sourced Truth  
**Status:** ✅ Passed (sealed)
- Event log is the sole source of truth
- Events are raw transport observations only
- Append-only, ordered, replayable
- No semantic interpretation at ingestion time

### TS2 — Semantic Projections  
**Status:** ✅ Passed (sealed)

**TS2-001 — First Semantic Projection**
- Proved semantic meaning can be derived from the event log
- Established purity, replay determinism, ordering inheritance
- Introduced first semantic object (EventKind)

**TS2-002 — Projection Identity & Registry**
- Introduced stable identity for semantic meaning
- Established declarative, inert projection registry
- Locked explicit versioning and coexistence
- Declared semantic dependency surfaces (`permitted_fields`)
- Registry is non-operational by construction

**TS2-003 — Projection Contract Drift**
- Enforced semantic dependency surfaces via tests
- Proved non-dependence on irrelevant fields
- Prevented semantic drift without runtime enforcement

### TS3 — Semantic Consumption & Distribution  
**Status:** ✅ Passed (sealed)

**TS3-001 — First Consumer Boundary (CLI)**
- CLI consumers (list, show, eval) are read-only
- Explicit `ProjectionId@version` required everywhere; no implicit “latest”
- Replay-equivalent to direct projection execution

**TS3-010 — Projection Feed (Pub/Sub)**
- Downstream-only semantic feed distributing Frames
- Frames keyed by explicit `ProjectionId@version`
- Replay-deterministic, rebuildable from the event log
- No raw event access or projection execution possible

**TS3-UI-001 — REPL & tmux Reintroduction (Read-Only)**
- UI surfaces consume Frames only
- No authority, no execution, no mutation
- Rendered output is deterministic and replay-equivalent

## Entering TS4 — Interaction & Control
Key shift: TS1–TS3 answer how meaning is derived and observed. TS4 introduces how intent and agency are expressed — without contaminating semantics. TS4 sits above the sealed semantic pipeline.

```
Event Log → Projection → Frame → Consumer   ← sealed
                     ↑
                 TS4 Intent
```

TS4 treats all TS3 outputs as observational only.

### TS4-001 — Intent Introduction (Control Plane Entry)
**Core question:** How does a user express intent without granting authority to consumers or contaminating semantic purity?

Introduces:
- A first-class Intent representation: immutable, typed, versioned, non-authoritative
- A single explicit intent entry point (CLI / REPL)
- Pure validation of intent without execution

Key invariants:
- Intent is not an Event
- Intent is not replayed
- Intent carries no authority on its own
- Semantic pipeline remains unchanged

Explicitly excludes:
- Execution
- Planners
- Async control
- UI-driven mutation
- Any change to projections, feed, or consumers

### TS4-002 — Intent Routing to Authority (Minimal)
**Core question:** How does validated intent reach authority without introducing new execution paths?

Introduces:
- Explicit routing of validated intent to the existing Controller
- Authority remains confined to Driver / Controller
- Execution effects expressed only as new Events

Key invariants:
- All effects are observed via Events
- No semantic shortcuts
- No UI → execution coupling
- Replay reconstructs effects, not choices

Explicitly excludes:
- Planners or schedulers
- Background execution
- UI-initiated control loops

### TS4-A — Session Lifecycle Intents
**Core question:** How does a user explicitly begin and end a controlled debug session?

Introduces:
- Explicit session lifecycle intents: `session.start`, `session.exit`

Key invariants:
- Session control is explicit
- No implicit restart or teardown
- All effects flow through Events

### TS4-B — Execution Control Intents
**Core question:** How does a user advance execution step-by-step without planners or loops?

Introduces:
- Explicit, synchronous execution intents: `run`, `continue`, `step`

Key invariants:
- One intent → one execution request
- No auto-repeat
- No stepping modes
- No async control

### TS4-C — Breakpoint Intents
**Core question:** How does a user control breakpoints without hidden state or semantic shortcuts?

Introduces:
- Explicit breakpoint intents: `breakpoint.add file:line` (optional `breakpoint.clear id`)

Key invariants:
- Breakpoint effects are observable via Events
- Breakpoint state is surfaced only via semantic projections
- No hidden breakpoint tables in the control plane

Notes:
- May introduce a small TS2-compatible projection (e.g. `breakpoint.list@1`)

### TS4-D — Register Observation (Completion)
**Core question:** How does a user observe machine state changes deterministically?

Introduces / completes:
- Register snapshot events
- Register semantic projections
- Stable register views in UI panes

Key invariants:
- Observation only
- No mutation
- Replay-equivalent register views

## v0.2 Definition of “Done”
Dipole v0.2 is considered complete when:
- TS1–TS3 semantic pipeline is sealed and replay-stable
- TS4 introduces explicit, contained agency
- A user can: start a session; set a breakpoint; run; step; observe registers; continue; exit
- All execution effects are expressed as Events
- Semantic meaning is derived unchanged via TS2–TS3
- UI surfaces remain strictly observational
- Replay determinism holds end-to-end (Events → Frames → Rendered output)

## Explicit Non-Goals for v0.2
- Async execution loops
- Conditional breakpoints
- Watchpoints
- Planners or schedulers
- UI-initiated execution
- Implicit versioning (“latest”)
- Semantic mutation or shortcuts
- Raw event access outside TS1

## Notes on Scope Discipline
- No slice introduces both meaning and authority
- TS4 widens intent coverage, not architecture
- UI remains observational
- Authority remains upstream and explicit
- Each slice ends with tests, docs, and a merge milestone

## Summary
This roadmap reflects Dipole’s true structure and ambition:

```
truth → meaning → distribution → observation → intent → authority
```
